# 2020-10-22

## 位运算之 Shift-Operator (左移、右移、无符号右移)

在Java的Specification中，定义了 shift operator 右边的数据会根据左边变量的类型，而截取不同的bit
* 如果左边是Int型，则右边支取低5位，相当于是：`& 0x1F`
* 如果昨天是Long型，则右边只取低6位，相当于是：`& 0x3F`

所以会有如下场景：

* 2 << 33 相当于 2 << (33 & 0x1F) then 2 << 1
* 2 << -30 相当于 2 << (-30 & 0x1F) then 2 << 2

参考资料： https://docs.oracle.com/javase/specs/jls/se15/html/jls-15.html#jls-15.19

摘录一下specification中的段落：
![reference-state1](pic/闲聊/java-bit-shift-20201022092638.jpg)


# 2020-10-17

## java.util.BitSet 阅读随笔

今天在复习BitMap数据结构在java中的实现BitSet时，看到了3个有关位图的运算，需要自己思考几分钟，下面特意记录下：

* In function wordIndex, use 'index >> ADDRESS_BITS_PER_WORD' to get the index of in words in which ADDRESS_BITS_PER_WORD = 6.

why can use >> instead of divide operation ?

Because the divisor is the integral multiple of 2， we use >> to improve the  performance.
Of course using dividing is right, but performance is bad. Let's make a testing.

```
public class BitMapTestor {
    private static final Logger LOG = LoggerFactory.getLogger(BitMapTestor.class);

    private final static int ADDRESS_BITS_PER_WORD = 6;
    private final static int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;

    @Test
    public void testBitOperations() {
        int bitIndex = 75;
        int indexByDvide = bitIndex / BITS_PER_WORD;
        int indexByBitOp = bitIndex >> ADDRESS_BITS_PER_WORD;
        Assert.assertEquals(indexByBitOp, indexByDvide);
    }
}
```
The testing is passed.

* In function wordIndex, use '1L << ADDRESS_BITS_PER_WORD' to get the word bit of indexing.

'<<' operation can left moving number over number's size like sliding window.

Let's make a testing.
```
public class BitMapTestor {
    private static final Logger LOG = LoggerFactory.getLogger(BitMapTestor.class);

    private final static int ADDRESS_BITS_PER_WORD = 6;
    private final static int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;

    @Test
    public void testBitOperations() {
        int v = 1 << 33;
        LOG.info("1 << 33 is {}", v);
        Assert.assertEquals(2, v);
    }
}

```
The testing is passed.

* In function clear, use 'long lastWordMask  = WORD_MASK >>> -toIndex;' to do unsigned moving the bit from left to right.

```
long firstWordMask = WORD_MASK << fromIndex;
        long lastWordMask  = WORD_MASK >>> -toIndex;
        if (startWordIndex == endWordIndex) {
            // Case 1: One word
            words[startWordIndex] &= ~(firstWordMask & lastWordMask);
        } else {
            // Case 2: Multiple words
            // Handle first word
            words[startWordIndex] &= ~firstWordMask;

            // Handle intermediate words, if any
            for (int i = startWordIndex+1; i < endWordIndex; i++)
                words[i] = 0;

            // Handle last word
            words[endWordIndex] &= ~lastWordMask;
        }
```

It's too awesome to implement make (, end) to be zero like below.

```

--------------*              *---------------
0000000000000 | 111111111111 | 00000000000000
--------------*--------------*--------------->
             end            start
```


## Bit operation 随笔

有两个问题：
* 如何对一个int型数字取反
* 如何对一个int型数字部分bit取反

下面分别讨论：

### 如何对一个int型数字取反

有两个办法：

* 第一种办法：通过位运算取反 ~
* 第二种办法：用过异或

```
int v = 0x89F0;
Assert.assertEquals(~v, v ^ 0xFFFFFFFF);
```

### 如何对一个int型数字部分bit取反

这个时候取反不满足要求，可以采用异或的办法。例如：

```
@Test
    public void testBitOperations2() {
        int v = 0x89F0;
        /**
         * 相比取反，异或方式更具有灵活性，可以只针对部分bit取反。
         *
         * 用于异或的数字，对应需要取反的部分都是1，其余是0
         * 例如：将第3、4、5 位的bit取反，可以这样
         *
         * -------------*     *-----
         * 000000000000 | 111 | 000
         * -------------*-----*-----
         *              ^     ^
         *              |     |
         *             end   start
         */
        int mask = 0xFFFFFFFF;
        int startMask = mask << 3;
        int endMask = mask >>> (32 - 6);
        int complementMask = startMask & endMask;

        Assert.assertEquals(0x89c8, v ^ complementMask);

        /**
         * 或者逐步异或
         */
        Assert.assertEquals(0x89c8, v ^ (1 << 3) ^ (1 << 4) ^ (1 << 5));
    }
```

异或是如何实现取反的操作？

下面拿1个bit来讨论：
* 1个bit无论它的值是0还是1，对1取异或都是取的反；
* 1个bit无论它的值是0还是1，对0取异或都是它自身



# 2020-08-26

总结一下最近几天看AQS-ConditionObject的认知变化。从问题角度出发

## 为什么waiting-queue中的线程被interrupted后，还需要先获取lock ？

首先：这个JDK 规范，可以参照Condition.wait 方法的说明

![reference-state1](pic/20200826230239-AQS-conditon-wait.jpg)


## 为什么waiting-queue中的线程被interrupted后，需要区分是在signal 之前还是之后？

## 为什么waiting-queue中的线程被interrupted后，并且是在signal之前，仅执行enq操作(将该node放入sync-queue)，不执行remove from waiting-queue？

## await方法中，当线程释放掉锁后(fullRelease)， 可能和后来拿到锁的线程有并发问题 ？

